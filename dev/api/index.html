<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · ADCME</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ADCME</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">ADCME Documentation</a></li><li><span class="toctext">Inverse Modeling</span></li><li><span class="toctext">Automatic Differentiation</span><ul><li><a class="toctext" href="../four_types/">Forward Operator Types</a></li></ul></li><li><span class="toctext">Useful Tools</span><ul><li><a class="toctext" href="../customop/">-</a></li><li><a class="toctext" href="../while_loop/">The Power of <code>while_loop</code> – Application to Finite Element Analysis</a></li><li><a class="toctext" href="../julia_customop/">Julia Custom Operators</a></li><li><a class="toctext" href="../extra/">Miscellaneous Tools</a></li></ul></li><li><span class="toctext">Applications</span></li><li><span class="toctext">API Reference</span><ul><li class="current"><a class="toctext" href>-</a><ul class="internal"><li><a class="toctext" href="#Core-Functions-1">Core Functions</a></li><li><a class="toctext" href="#Variables-1">Variables</a></li><li><a class="toctext" href="#Random-Variables-1">Random Variables</a></li><li><a class="toctext" href="#Sparse-Matrix-1">Sparse Matrix</a></li><li><a class="toctext" href="#Operations-1">Operations</a></li><li><a class="toctext" href="#Neural-Network-Utilities-1">Neural Network Utilities</a></li><li><a class="toctext" href="#IO-1">IO</a></li><li><a class="toctext" href="#Optimization-1">Optimization</a></li><li><a class="toctext" href="#Generative-Neural-Nets-1">Generative Neural Nets</a></li><li><a class="toctext" href="#Tools-1">Tools</a></li><li><a class="toctext" href="#Datasets-1">Datasets</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API Reference</li><li><a href>-</a></li></ul><a class="edit-page" href="https://github.com/kailaix/ADCME.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>-</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="Core-Functions-1" href="#Core-Functions-1">Core Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.Diary" href="#ADCME.Diary"><code>ADCME.Diary</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Diary(suffix::Union{String, Nothing}=nothing)</code></pre><p>Creates a diary at a temporary directory path. It returns a writer and the corresponding directory path</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/io.jl#L136-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.GAN" href="#ADCME.GAN"><code>ADCME.GAN</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>GAN(dat::PyObject, generator::Function, gan::GAN, loss::Union{String, Function, Missing}=missing; latent_dim::Union{Missing, Int64}=missing, batch_size::Union{Missing, Int64}=missing)</code></p><p>Users must provide: <code>dat</code>, <code>generator</code>, <code>discriminator</code>, <code>loss</code> (string or function)  Alternative argument: <code>latent_dim</code>, <code>batch_size</code> Training process is the most creative part and therefore no built-in algorithm is provided.  Users have access to <code>d_loss</code>, <code>g_loss</code>, <code>d_vars</code>, <code>g_vars</code>, which are sufficient for designing training algorithms.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/gan.jl#L9-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.SparseTensor-Tuple{SparseArrays.SparseMatrixCSC}" href="#ADCME.SparseTensor-Tuple{SparseArrays.SparseMatrixCSC}"><code>ADCME.SparseTensor</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SparseTensor(A::SparseMatrixCSC)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/sparse.jl#L80-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.SparseTensor-Union{Tuple{S}, Tuple{T}, Tuple{Union{Array{T,1}, PyObject},Union{Array{T,1}, PyObject},Union{Array{Float64,1}, PyObject}}, Tuple{Union{Array{T,1}, PyObject},Union{Array{T,1}, PyObject},Union{Array{Float64,1}, PyObject},Union{Nothing, PyObject, S}}, Tuple{Union{Array{T,1}, PyObject},Union{Array{T,1}, PyObject},Union{Array{Float64,1}, PyObject},Union{Nothing, PyObject, S},Union{Nothing, PyObject, S}}} where S&lt;:Integer where T&lt;:Integer" href="#ADCME.SparseTensor-Union{Tuple{S}, Tuple{T}, Tuple{Union{Array{T,1}, PyObject},Union{Array{T,1}, PyObject},Union{Array{Float64,1}, PyObject}}, Tuple{Union{Array{T,1}, PyObject},Union{Array{T,1}, PyObject},Union{Array{Float64,1}, PyObject},Union{Nothing, PyObject, S}}, Tuple{Union{Array{T,1}, PyObject},Union{Array{T,1}, PyObject},Union{Array{Float64,1}, PyObject},Union{Nothing, PyObject, S},Union{Nothing, PyObject, S}}} where S&lt;:Integer where T&lt;:Integer"><code>ADCME.SparseTensor</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SparseTensor(I::Union{PyObject,Array{T,1}}, J::Union{PyObject,Array{T,1}}, V::Union{Array{Float64,1}, PyObject}, m::Union{S, PyObject, Nothing}=nothing, n::Union{S, PyObject, Nothing}=nothing) where {T&lt;:Integer, S&lt;:Integer}</code></pre><p>Constructs a sparse tensor.  Examples:</p><pre><code class="language-none">ii = [1;2;3;4]
jj = [1;2;3;4]
vv = [1.0;1.0;1.0;1.0]
s = SparseTensor(ii, jj, vv, 4, 4)
s = SparseTensor(sprand(10,10,0.3))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/sparse.jl#L12-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.BFGS!" href="#ADCME.BFGS!"><code>ADCME.BFGS!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">BFGS!(value_and_gradients_function::Function, initial_position::Union{PyObject, Array{Float64}}, max_iter::Int64=50, args...;kwargs...)</code></pre><p>Applies the BFGS optimizer to <code>value_and_gradients_function</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/optim.jl#L198-L202">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.BFGS!" href="#ADCME.BFGS!"><code>ADCME.BFGS!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>BFGS!(sess::PyObject, loss::PyObject, max_iter::Int64=15000; kwargs...)</p><p><code>BFGS!</code> is a simplified interface for BFGS optimizer. </p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/optim.jl#L168-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.CustomOptimizer-Tuple{Function}" href="#ADCME.CustomOptimizer-Tuple{Function}"><code>ADCME.CustomOptimizer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>CustomOptimizer(opt::Function, name::String)</p><p>creates a custom optimizer with struct name <code>name</code>. For example, we can integrate <code>Optim.jl</code> with <code>ADCME</code> by  constructing a new optimizer</p><pre><code class="language-julia">CustomOptimizer(&quot;Con&quot;) do f, df, c, dc, x0, nineq, neq, x_L, x_U
    opt = Opt(:LD_MMA, length(x0))
    bd = zeros(length(x0)); bd[end-1:end] = [-Inf, 0.0]
    opt.lower_bounds = bd
    opt.xtol_rel = 1e-4
    opt.min_objective = (x,g)-&gt;(g[:]= df(x); return f(x)[1])
    inequality_constraint!(opt, (x,g)-&gt;( g[:]= dc(x);c(x)[1]), 1e-8)
    (minf,minx,ret) = NLopt.optimize(opt, x0)
    minx
end</code></pre><p>Then we can create an optimizer with </p><pre><code class="language-none">opt = Con(loss, inequalities=[c1], equalities=[c2])</code></pre><p>To trigger the optimization, use</p><pre><code class="language-none">opt.minimize(sess)</code></pre><p>or </p><pre><code class="language-none">minimize(opt, sess)</code></pre><p>Note thanks to the global variable scope of Julia, <code>step_callback</code>, <code>optimizer_kwargs</code> can actually  be passed from Julia environment directly.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/optim.jl#L88-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.NonlinearConstrainedProblem-Union{Tuple{T}, Tuple{Function,Function,Union{Array{Float64,1}, PyObject},Union{PyObject, Array{Float64,N} where N}}} where T&lt;:Real" href="#ADCME.NonlinearConstrainedProblem-Union{Tuple{T}, Tuple{Function,Function,Union{Array{Float64,1}, PyObject},Union{PyObject, Array{Float64,N} where N}}} where T&lt;:Real"><code>ADCME.NonlinearConstrainedProblem</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">NonlinearConstrainedProblem(f::Function, L::Function, θ::PyObject, u0::Union{PyObject, Array{Float64}}; options::Union{Dict{String, T}, Missing}=missing) where T&lt;:Integer</code></pre><p>Computes the gradients <span>$\frac{\partial L}{\partial \theta}$</span></p><div>\[\begin{align}
\min &amp; \ L(u)\\ 
\mathrm{s.t.} &amp; \ F(\theta, u) = 0
\end{align}\]</div><p><code>u0</code> is the initial guess for the numerical solution <code>u</code>, see <a href="#ADCME.newton_raphson-Union{Tuple{T}, Tuple{Function,Union{PyObject, Array}}, Tuple{Function,Union{PyObject, Array},Union{Missing, PyObject, Array{#s92,N} where N where #s92&lt;:Real}}} where T&lt;:Real"><code>newton_raphson</code></a>.</p><p>Caveats: Assume <code>r, A = f(θ, u)</code> and <code>θ</code> are the unknown parameters, <code>gradients(r, θ)</code> must be defined (backprop works properly)</p><p>Returns: It returns a tuple (<code>L</code>: loss, <code>C</code>: constraints, and <code>Graidents</code>)</p><div>\[\left(L(u), u, \frac{\partial L}{\partial θ}\right)\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/optim.jl#L365-L387">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.ScipyOptimizerInterface-Tuple{Any}" href="#ADCME.ScipyOptimizerInterface-Tuple{Any}"><code>ADCME.ScipyOptimizerInterface</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>ScipyOptimizerInterface(     loss,     var<em>list=None,     equalities=None,     inequalities=None,     var</em>to<em>bounds=None,     **optimizer</em>kwargs ) https://www.tensorflow.org/api_docs/python/tf/contrib/opt/ScipyOptimizerInterface</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/optim.jl#L46-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.ScipyOptimizerMinimize-Tuple{PyObject,PyObject}" href="#ADCME.ScipyOptimizerMinimize-Tuple{PyObject,PyObject}"><code>ADCME.ScipyOptimizerMinimize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>ScipyOptimizerMinimize(     session=None,     feed<em>dict=None,     fetches=None,     step</em>callback=None,     loss<em>callback=None,     **run</em>kwargs ) Minimize a scalar Tensor.</p><p>Variables subject to optimization are updated in-place at the end of optimization.</p><p>Note that this method does not just return a minimization Op, unlike <code>minimize</code>; instead it actually performs minimization by executing commands to control a Session https://www.tensorflow.org/api_docs/python/tf/contrib/opt/ScipyOptimizerInterface</p><p><strong>kwargs</strong></p><p>– feed<em>dict: A feed dict to be passed to calls to session.run. – fetches: A list of Tensors to fetch and supply to loss</em>callback as positional arguments. – step<em>callback: A function to be called at each optimization step; arguments are the current values of all optimization variables flattened into a single vector. – loss</em>callback: A function to be called every time the loss and gradients are computed, with evaluated fetches supplied as positional arguments. – run_kwargs: kwargs to pass to session.run.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/optim.jl#L60-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.SparseAssembler-Tuple{}" href="#ADCME.SparseAssembler-Tuple{}"><code>ADCME.SparseAssembler</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>accumulator, creater, initializer = SparseAssembler()</p><p>Returns 3 functions that can be used for assembling sparse matrices concurrently.</p><ul><li><code>initializer</code> must be called before the working session</li><li><code>accumulator</code> accumulates column indices and values </li><li><code>creator</code> accepts no input and outputs row indices, column indices and values for the sparse matrix</li></ul><p>Example:</p><pre><code class="language-none">accumulator, creater, initializer = SparseAssembler()
initializer(5)
op1 = accumulator(1, [1;2;3], ones(3))
op2 = accumulator(1, [3], [1.])
op3 = accumulator(2, [1;3], ones(2))
run(sess, [op1,op2,op3])
ii,jj,vv = creater()
i,j,v = run(sess, [ii,jj,vv])
A = sparse(i,j,v,5,5)
@assert Array(A)≈[1.0  1.0  2.0  0.0  0.0
                1.0  0.0  1.0  0.0  0.0
                0.0  0.0  0.0  0.0  0.0
                0.0  0.0  0.0  0.0  0.0
                0.0  0.0  0.0  0.0  0.0]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/sparse.jl#L252-L279">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.activate" href="#ADCME.activate"><code>ADCME.activate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">activate(sw::Diary, port::Int64=6006)</code></pre><p>Running <a href="#ADCME.Diary"><code>Diary</code></a> at http://localhost:port.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/io.jl#L166-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.add_collection-Tuple{String,PyObject}" href="#ADCME.add_collection-Tuple{String,PyObject}"><code>ADCME.add_collection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">add_collection(name::String, v::PyObject)</code></pre><p>Adds <code>v</code> to the collection with name <code>name</code>. If <code>name</code> does not exist, a new one is created.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/core.jl#L38-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.add_collection-Tuple{String,Vararg{PyObject,N} where N}" href="#ADCME.add_collection-Tuple{String,Vararg{PyObject,N} where N}"><code>ADCME.add_collection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">add_collection(name::String, vs::PyObject...)</code></pre><p>Adds operators <code>vs</code> to the collection with name <code>name</code>. If <code>name</code> does not exist, a new one is created.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/core.jl#L48-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.ae" href="#ADCME.ae"><code>ADCME.ae</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ae(x::PyObject, output_dims::Array{Int64}, scope::String = &quot;default&quot;)</code></pre><p>Creates a neural network with intermediate numbers of neurons <code>output_dims</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/layers.jl#L58-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.ae-Tuple{Union{PyObject, Array{Float64,N} where N},Array{Int64,N} where N,Union{PyObject, Array{Float64,N} where N}}" href="#ADCME.ae-Tuple{Union{PyObject, Array{Float64,N} where N},Array{Int64,N} where N,Union{PyObject, Array{Float64,N} where N}}"><code>ADCME.ae</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ae(x::Union{Array{Float64}, PyObject}, output_dims::Array{Int64}, θ::Union{Array{Float64}, PyObject})</code></pre><p>Creates a neural network with intermediate numbers of neurons <code>output_dims</code>. The weights are given by <code>θ</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/layers.jl#L85-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.ae_init-Tuple{PyObject,Union{PyObject, Array{Float64,N} where N},Array{Int64,N} where N}" href="#ADCME.ae_init-Tuple{PyObject,Union{PyObject, Array{Float64,N} where N},Array{Int64,N} where N}"><code>ADCME.ae_init</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ae_init(sess::PyObject, x::Union{Array{Float64}, PyObject}, output_dims::Array{Int64})</code></pre><p>Return the initial weights and bias values by TensorFlow as a vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/layers.jl#L125-L129">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.bn-Tuple" href="#ADCME.bn-Tuple"><code>ADCME.bn</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>example: bn(inputs, name=&quot;batch<em>norm&quot;, is</em>training=true)</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/layers.jl#L246-L249">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.categorical-Tuple{Union{Integer, PyObject}}" href="#ADCME.categorical-Tuple{Union{Integer, PyObject}}"><code>ADCME.categorical</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>categorical(n::Union{PyObject, Integer}; kwargs...)</p><p><code>kwargs</code> has a keyword argument <code>logits</code>, a 2-D Tensor with shape <code>[batch_size, num_classes]</code>.   Each slice <code>[i, :]</code> represents the unnormalized log-probabilities for all classes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/random.jl#L16-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.choice-Tuple{Union{PyObject, Array},Union{Integer, PyObject}}" href="#ADCME.choice-Tuple{Union{PyObject, Array},Union{Integer, PyObject}}"><code>ADCME.choice</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>choice(inputs::Union{PyObject, Array}, n_samples::Union{PyObject, Integer};replace::Bool=false)</p><p>Choose <code>n_samples</code> samples from <code>inputs</code> with/without replacement. </p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/random.jl#L41-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.compile_op-Tuple{String}" href="#ADCME.compile_op-Tuple{String}"><code>ADCME.compile_op</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">compile_op(oplibpath::String, opname::String)</code></pre><p>Compile the library operator by force.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/extra.jl#L50-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.customop" href="#ADCME.customop"><code>ADCME.customop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">customop(torch=false; julia=false)</code></pre><p>Create a new custom operator.</p><p><strong>example</strong></p><pre><code class="language-julia-repl">julia&gt; customop() # create an editable `customop.txt` file
[ Info: Custom operator wrapper generated; Torch is disabled

julia&gt; customop() # after editing `customop.txt`, call it again to generate interface files.
[ Info: Custom operator wrapper generated; Torch is disabled</code></pre><p>The option <code>torch</code> adds support for <code>PyTorch</code> backend in <code>CMakeLists.txt</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/extra.jl#L209-L223">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.find-Tuple{SparseTensor}" href="#ADCME.find-Tuple{SparseTensor}"><code>ADCME.find</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">find(s::SparseTensor)</code></pre><p>Returns the row, column and values for sparse tensor <code>s</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/sparse.jl#L49-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.get_collection" href="#ADCME.get_collection"><code>ADCME.get_collection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">get_collection(name::Union{String, Missing})</code></pre><p>Returns the collection with name <code>name</code>. If <code>name</code> is <code>missing</code>, returns all the trainable variables.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/core.jl#L24-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.gradients-Tuple{PyObject,PyObject}" href="#ADCME.gradients-Tuple{PyObject,PyObject}"><code>ADCME.gradients</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>gradients compute the gradients of ys w.r.t xs It incoperates <code>jacobian</code> and <code>hessian</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/variable.jl#L125-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.group_assign-Tuple{Array{PyObject,N} where N,Any,Vararg{Any,N} where N}" href="#ADCME.group_assign-Tuple{Array{PyObject,N} where N,Any,Vararg{Any,N} where N}"><code>ADCME.group_assign</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>group_assign(os::Array{PyObject}, values, args...; kwargs...)</p><p>apply <code>assign</code> to each element of <code>os</code> and <code>values</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/ops.jl#L288-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.has_gpu-Tuple{}" href="#ADCME.has_gpu-Tuple{}"><code>ADCME.has_gpu</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">has_gpu()</code></pre><p>Checks if GPU is available.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/core.jl#L178-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.hessian-Tuple{PyObject,PyObject}" href="#ADCME.hessian-Tuple{PyObject,PyObject}"><code>ADCME.hessian</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>hessian</code> computes the hessian of a scalar function f with respect to vector inputs xs</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/variable.jl#L233-L235">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.if_else-Tuple{Union{Bool, PyObject, Array},Any,Any,Vararg{Any,N} where N}" href="#ADCME.if_else-Tuple{Union{Bool, PyObject, Array},Any,Any,Vararg{Any,N} where N}"><code>ADCME.if_else</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">if_else(condition::Union{PyObject,Array,Bool}, fn1, fn2, args...;kwargs...)</code></pre><ul><li>If <code>condition</code> is a scalar boolean, it outputs <code>fn1</code> or <code>fn2</code> (a function with no input argument or a tensor) based on whether <code>condition</code> is true or false.</li><li>If <code>condition</code> is a boolean array, if returns <code>condition .* fn1 + (1 - condition) .* fn2</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/core.jl#L161-L166">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.load" href="#ADCME.load"><code>ADCME.load</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">load(sess::PyObject, file::String, vars::Union{PyObject, Nothing, Array{PyObject}}=nothing, args...; kwargs...)</code></pre><p>Loads the values of variables to the session <code>sess</code> from the file <code>file</code>. If <code>vars</code> is nothing, it loads values to all the trainable variables. See also <a href="#ADCME.save"><code>save</code></a>, <a href="#ADCME.load"><code>load</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/io.jl#L82-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.load-Tuple{Diary,String}" href="#ADCME.load-Tuple{Diary,String}"><code>ADCME.load</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">load(sw::Diary, dirp::String)</code></pre><p>Loads <a href="#ADCME.Diary"><code>Diary</code></a> from <code>dirp</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/io.jl#L156-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.load_op-Tuple{String,String}" href="#ADCME.load_op-Tuple{String,String}"><code>ADCME.load_op</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>load_op(oplibpath::String, opname::String)</p><p>loads the operator <code>opname</code> from library <code>oplibpath</code>,  if the surfix of <code>oplibpath</code> is not given, it will be inferred from system</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/extra.jl#L74-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.newton_raphson-Union{Tuple{T}, Tuple{Function,Union{PyObject, Array}}, Tuple{Function,Union{PyObject, Array},Union{Missing, PyObject, Array{#s92,N} where N where #s92&lt;:Real}}} where T&lt;:Real" href="#ADCME.newton_raphson-Union{Tuple{T}, Tuple{Function,Union{PyObject, Array}}, Tuple{Function,Union{PyObject, Array},Union{Missing, PyObject, Array{#s92,N} where N where #s92&lt;:Real}}} where T&lt;:Real"><code>ADCME.newton_raphson</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">newton_raphson(f::Function, u::Union{Array,PyObject}, θ::Union{Missing,PyObject}; options::Union{Dict{String, T}, Missing}=missing)</code></pre><p>Newton Raphson solver for solving a nonlinear equation.  <code>f</code> has the signature <code>f(u::PyObject, θ::Union{Missing,PyObject})-&gt;(r::PyObject, A::Union{PyObject,SparseTensor})</code> where <code>r</code> is the residual and <code>A</code> is the Jacobian matrix.  <code>θ</code> are external parameters. <code>u0</code> is the initial guess for <code>u</code> <code>options</code>:</p><ul><li>&quot;max_iter&quot;: maximum number of iterations (default=100)</li><li>&quot;verbose&quot;: whether details are printed (default=false)</li><li>&quot;rtol&quot;: relative tolerance for termination (default=1e-12)</li><li>&quot;tol&quot;: absolute tolerance for termination (default=1e-12)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/optim.jl#L221-L234">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.num_ae-Tuple{Array{Int64,N} where N}" href="#ADCME.num_ae-Tuple{Array{Int64,N} where N}"><code>ADCME.num_ae</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">num_ae(output_dims::Array{Int64})</code></pre><p>Estimates the number of weights for the neural network.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/layers.jl#L145-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.pload-Tuple{String}" href="#ADCME.pload-Tuple{String}"><code>ADCME.pload</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">pload(file::String)</code></pre><p>Loads a Python objection from <code>file</code>. See also <a href="#ADCME.psave"><code>psave</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/io.jl#L30-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.psave-Tuple{PyObject,String}" href="#ADCME.psave-Tuple{PyObject,String}"><code>ADCME.psave</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">psave(o::PyObject, file::String)</code></pre><p>Saves a Python objection <code>o</code> to <code>file</code>. See also <a href="#ADCME.pload"><code>pload</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/io.jl#L18-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.reset_default_graph-Tuple{}" href="#ADCME.reset_default_graph-Tuple{}"><code>ADCME.reset_default_graph</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">reset_default_graph()</code></pre><p>Resets the graph by removing all the operators. </p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/core.jl#L18-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.save" href="#ADCME.save"><code>ADCME.save</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">save(sess::PyObject, file::String, vars::Union{PyObject, Nothing, Array{PyObject}}=nothing, args...; kwargs...)</code></pre><p>Saves the values of <code>vars</code> in the session <code>sess</code>. The result is written into <code>file</code> as a dictionary. If <code>vars</code> is nothing, it saves all the trainable variables. See also <a href="#ADCME.save"><code>save</code></a>, <a href="#ADCME.load"><code>load</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/io.jl#L44-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.save-Tuple{Diary,String}" href="#ADCME.save-Tuple{Diary,String}"><code>ADCME.save</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">save(sw::Diary, dirp::String)</code></pre><p>Saves <a href="#ADCME.Diary"><code>Diary</code></a> to <code>dirp</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/io.jl#L147-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.scalar" href="#ADCME.scalar"><code>ADCME.scalar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">scalar(o::PyObject, name::String)</code></pre><p>Returns a scalar summary object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/io.jl#L176-L180">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.spdiag-Tuple{Int64}" href="#ADCME.spdiag-Tuple{Int64}"><code>ADCME.spdiag</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">spdiag(n::Int64)</code></pre><p>Constructs a sparse identity matrix of size <span>$n\times n$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/sparse.jl#L304-L308">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.spdiag-Tuple{PyObject}" href="#ADCME.spdiag-Tuple{PyObject}"><code>ADCME.spdiag</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">spdiag(o::PyObject)</code></pre><p>Constructs a sparse diagonal matrix where the diagonal entries are <code>o</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/sparse.jl#L313-L317">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.spzero" href="#ADCME.spzero"><code>ADCME.spzero</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">spzero(m::Int64, n::Union{Missing, Int64}=missing)</code></pre><p>Constructs a empty sparse matrix of size <span>$m\times n$</span>. <code>n=m</code> if <code>n</code> is <code>missing</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/sparse.jl#L326-L330">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.tensor-Tuple{String}" href="#ADCME.tensor-Tuple{String}"><code>ADCME.tensor</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tensor(s::String)</code></pre><p>Returns the tensor with name <code>s</code>. See <a href="#ADCME.tensorname-Tuple{PyObject}"><code>tensorname</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/core.jl#L60-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.tensorname-Tuple{PyObject}" href="#ADCME.tensorname-Tuple{PyObject}"><code>ADCME.tensorname</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tensorname(o::PyObject)</code></pre><p>Returns the name of the tensor. See <a href="#ADCME.tensor-Tuple{String}"><code>tensor</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/core.jl#L69-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.tic" href="#ADCME.tic"><code>ADCME.tic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tic(o::PyObject, i::Union{PyObject, Integer}=0)</code></pre><p>Construts a TensorFlow timer with index <code>i</code>. The start time record is right before <code>o</code> is executed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/extra.jl#L282-L286">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.toc" href="#ADCME.toc"><code>ADCME.toc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">toc(o::PyObject, i::Union{PyObject, Integer}=0)</code></pre><p>Returns the elapsed time from last <a href="#ADCME.tic"><code>tic</code></a> call with index <code>i</code> (default=0). The terminal time record is right before <code>o</code> is executed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/extra.jl#L295-L299">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.vector-Union{Tuple{T}, Tuple{Union{PyObject, StepRange, UnitRange, Array{T,N} where N},Union{PyObject, Array{Float64,N} where N},Union{Int64, PyObject}}} where T&lt;:Integer" href="#ADCME.vector-Union{Tuple{T}, Tuple{Union{PyObject, StepRange, UnitRange, Array{T,N} where N},Union{PyObject, Array{Float64,N} where N},Union{Int64, PyObject}}} where T&lt;:Integer"><code>ADCME.vector</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vector(i::Union{Array{T}, PyObject, UnitRange, StepRange}, v::Union{Array{Float64},PyObject},s::Union{Int64,PyObject})</code></pre><p>Returns a vector <code>V</code> with length <code>s</code> such that</p><pre><code class="language-none">V[i] = v</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/ops.jl#L644-L651">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.compile-Tuple{String}" href="#ADCME.compile-Tuple{String}"><code>ADCME.compile</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>compile(s::String) Compile the library <code>s</code> by force.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/extra.jl#L185-L188">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.gradients10-Tuple{PyObject,PyObject}" href="#ADCME.gradients10-Tuple{PyObject,PyObject}"><code>ADCME.gradients10</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>gradients_v computes the gradients of a vector function f(x) w.r.t. a single variable x <code>ys</code> is the n dimensional vector function  <code>xs</code> is a scalar </p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/variable.jl#L171-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.gradients11-Tuple{PyObject,PyObject}" href="#ADCME.gradients11-Tuple{PyObject,PyObject}"><code>ADCME.gradients11</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>jacobian</code> computes the jacobian of a vector function f with respect to a vector variable x the output is |f| x |x| matrix</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/variable.jl#L209-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ADCME.load_system_op" href="#ADCME.load_system_op"><code>ADCME.load_system_op</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>function load<em>system</em>op(s::String, oplib::String, grad::Bool=true)</p><p>Load custom operator from CustomOps directory (shipped with ADCME instead of TensorFlow) For example </p><pre><code class="language-none">s = &quot;SparseOperator&quot;
oplib = &quot;libSO&quot;
grad = true</code></pre><p>this will direct Julia to find library <code>CustomOps/SparseOperator/libSO.dylib</code> on MACOSX</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/extra.jl#L149-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.bind-Tuple{PyObject,Vararg{Any,N} where N}" href="#Base.bind-Tuple{PyObject,Vararg{Any,N} where N}"><code>Base.bind</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bind(op::PyObject, ops...)</code></pre><p>Adding operations <code>ops</code> to the dependencies of <code>op</code>. The function is useful when we want to execute <code>ops</code> but <code>ops</code> is not  in the dependency of the final output. For example, if we want to print <code>i</code> each time <code>i</code> is evaluated</p><pre><code class="language-julia">i = constant(1.0)
op = tf.print(i)
i = bind(i, op)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/core.jl#L107-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reshape-Tuple{PyObject,Integer}" href="#Base.reshape-Tuple{PyObject,Integer}"><code>Base.reshape</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p><code>reshape</code> is designed so that we can think of tensors in column major</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/ops.jl#L133-L135">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.write-Tuple{Diary,Int64,Union{String, Array{String,N} where N}}" href="#Base.write-Tuple{Diary,Int64,Union{String, Array{String,N} where N}}"><code>Base.write</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">write(sw::Diary, step::Int64, cnt::Union{String, Array{String}})</code></pre><p>Writes to <a href="#ADCME.Diary"><code>Diary</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/ADCME.jl/blob/327056896c207a311af2cdf2f288a8b682fa62ba/src/io.jl#L188-L192">source</a></section><h2><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h2><h2><a class="nav-anchor" id="Random-Variables-1" href="#Random-Variables-1">Random Variables</a></h2><h2><a class="nav-anchor" id="Sparse-Matrix-1" href="#Sparse-Matrix-1">Sparse Matrix</a></h2><h2><a class="nav-anchor" id="Operations-1" href="#Operations-1">Operations</a></h2><h2><a class="nav-anchor" id="Neural-Network-Utilities-1" href="#Neural-Network-Utilities-1">Neural Network Utilities</a></h2><h2><a class="nav-anchor" id="IO-1" href="#IO-1">IO</a></h2><h2><a class="nav-anchor" id="Optimization-1" href="#Optimization-1">Optimization</a></h2><h2><a class="nav-anchor" id="Generative-Neural-Nets-1" href="#Generative-Neural-Nets-1">Generative Neural Nets</a></h2><h2><a class="nav-anchor" id="Tools-1" href="#Tools-1">Tools</a></h2><h2><a class="nav-anchor" id="Datasets-1" href="#Datasets-1">Datasets</a></h2><footer><hr/><a class="previous" href="../extra/"><span class="direction">Previous</span><span class="title">Miscellaneous Tools</span></a></footer></article></body></html>
