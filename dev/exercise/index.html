<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Exercise: Estimating Thermal Thermal Diffusivity Distribution from Sparse Sensor Measurements · ADCME</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ADCME logo"/></a><div class="docs-package-name"><span class="docs-autofit">ADCME</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/">Overview</a></li><li><a class="tocitem" href="../tu_whatis/">What is ADCME? Computational Graph, Automatic Differentiation &amp; TensorFlow</a></li><li><a class="tocitem" href="../tu_basic/">ADCME Basics: Tensor, Type, Operator, Session &amp; Kernel</a></li><li><a class="tocitem" href="../tu_sparse/">Sparse Linear Algebra</a></li><li><a class="tocitem" href="../tu_fd/">Numerical Scheme in ADCME: Finite Difference Example</a></li><li><a class="tocitem" href="../tu_fem/">Numerical Scheme in ADCME: Finite Element Example</a></li><li><a class="tocitem" href="../tu_inv/">Inverse Modeling with ADCME</a></li><li><a class="tocitem" href="../tu_recipe/">Inverse Modeling Recipe</a></li><li><a class="tocitem" href="../tu_implicit/">Advanced: Automatic Differentiation for Implicit Operators</a></li><li class="is-active"><a class="tocitem" href>Exercise: Estimating Thermal Thermal Diffusivity Distribution from Sparse Sensor Measurements</a><ul class="internal"><li><a class="tocitem" href="#Problem-1:-1D-Case-1"><span>Problem 1: 1D Case</span></a></li><li><a class="tocitem" href="#Problem-2:-2D-Case-1"><span>Problem 2: 2D Case</span></a></li></ul></li></ul></li><li><span class="tocitem">Resources</span><ul><li><a class="tocitem" href="../newton_raphson/">Newton Raphson</a></li><li><a class="tocitem" href="../parallel/">Parallel Computing</a></li><li><a class="tocitem" href="../ode/">PDE/ODE Solvers</a></li><li><a class="tocitem" href="../customop/">Custom Operators</a></li><li><a class="tocitem" href="../global/">Shared Memory Across Kernels</a></li><li><a class="tocitem" href="../julia_customop/">Julia Custom Operators</a></li><li><a class="tocitem" href="../nn/">Neural Networks</a></li><li><a class="tocitem" href="../extra/">Miscellaneous Tools</a></li><li><a class="tocitem" href="../ot/">Optimal Transport</a></li><li><a class="tocitem" href="../resource_manager/">Resource Manager</a></li></ul></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="../apps/">Overview</a></li><li><a class="tocitem" href="../apps_ana/">Adversarial Numerical Analysis</a></li><li><a class="tocitem" href="../apps_levy/">Calibrating Multivariate Lévy Processes with Neural Networks</a></li><li><a class="tocitem" href="../apps_constitutive_law/">Learning Constitutive Relations from Indirect Observations Using Deep Neural Networks</a></li><li><a class="tocitem" href="../apps_ad/">Intelligent Automatic Differentiation</a></li><li><a class="tocitem" href="../apps_adseismic/">General Seismic Inversion using Automatic Differentiation</a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Exercise: Estimating Thermal Thermal Diffusivity Distribution from Sparse Sensor Measurements</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Exercise: Estimating Thermal Thermal Diffusivity Distribution from Sparse Sensor Measurements</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kailaix/ADCME.jl/blob/master/docs/src/exercise.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Exercise:-Estimating-Thermal-Thermal-Diffusivity-Distribution-from-Sparse-Sensor-Measurements-1"><a class="docs-heading-anchor" href="#Exercise:-Estimating-Thermal-Thermal-Diffusivity-Distribution-from-Sparse-Sensor-Measurements-1">Exercise: Estimating Thermal Thermal Diffusivity Distribution from Sparse Sensor Measurements</a><a class="docs-heading-anchor-permalink" href="#Exercise:-Estimating-Thermal-Thermal-Diffusivity-Distribution-from-Sparse-Sensor-Measurements-1" title="Permalink"></a></h1><p>We saw in the lectures how to implement numerical PDE schemes in ADCME and use the forward computation codes to do inverse modeling with automatic differentiation. Here we apply the concepts of inverse modeling to a learning task–-estimate the thermal diffusivity distribution in a material from sparse sensor measurements. The <strong>thermal diffusivity</strong> is the measure of the ease at which the heat can pass through a material. It relies on the material property. Let <span>$T$</span> be the temperature, and <span>$\kappa$</span> be the thermal diffusivity, the Fourier&#39;s law of heat transfer says</p><div>\[\frac{\partial u(\mathbf{x}, t)}{\partial t} = \kappa\Delta u(\mathbf{x}, t) + f(\mathbf{x}, t), \quad t\in [0,T], x\in \Omega \tag{1}\]</div><p>Here <span>$f$</span> is the heat source and <span>$\Omega$</span> is the domain.</p><p>To make use of the heat equation, we need addition information. </p><ul><li><p><strong>Initial Condition</strong>: the initial temperature distribution is given <span>$u(\mathbf{x}, 0) = u_0(\mathbf{x})$</span>. </p></li><li><p><strong>Boundary Conditions</strong>: the temperature of the material is affected by what happens on the boundary. There are several possible boundary conditions. In this exercise we consider two of them:</p><p>(1) Temperature fixed at a boundary,</p><p><span>$u(\mathbf{x}, t) = 0, \mathbf{x}\in \Gamma_u \tag{2}$</span></p><p>(2) Insulated boundary. The heat flow can be prescribed (known as the <em>no flow</em> boundary condition)</p><div>\[-\kappa\frac{\partial u(\mathbf{x},t)}{\partial n} = 0, \mathbf{x}\in \Gamma_N \tag{3}\]</div><p>Here <span>$n$</span> is the outward normal vector. </p><p>The boundaries <span>$\Gamma_u$</span> and <span>$\Gamma_N$</span> satisfies <span>$\partial \Omega = \Gamma_u \cup \Gamma_N$</span></p></li></ul><p>Assume that we want to experiment with a piece of new material. The material has heterogenous properties in that the thermal diffusivity is a function of the space, i.e., <span>$\kappa(\mathbf{x})$</span>. This is the quantity we want to estimate. To this end, we place some sensors in the domain or on the boundary. The measurements are sparse in the sense that only the temperature from those sensors can be collected. Namely, let the sensors be located at <span>$\{\mathbf{x}_i\}_{i=1}^M$</span>, then we can observe <span>$\{\hat u(\mathbf{x}_i, t)\}_{i=1}^M$</span>, i.e., the measurements of <span>$\{ u(\mathbf{x}_i, t)\}_{i=1}^M$</span>. We also assume that the boundary conditions, initial conditions and the source terms are known. </p><h2 id="Problem-1:-1D-Case-1"><a class="docs-heading-anchor" href="#Problem-1:-1D-Case-1">Problem 1: 1D Case</a><a class="docs-heading-anchor-permalink" href="#Problem-1:-1D-Case-1" title="Permalink"></a></h2><p>We first consider the simpler 1D case. In this problem the material is a rod <span>$\Omega=[0,1]$</span>. We consider a homogeneous (zero) fixed boundary condition on the left side, and an insulated boundary on the right side. </p><p>(a) Write down the mathematical optimization problem for the inverse modeling.</p><p>Now we consider the discretization of the forward problem. We divide the domain <span>$[0,1]$</span> into <span>$n$</span> equi-spaced intervals. We consider the time horizon <span>$T = 10$</span>, and divide the time horizon <span>$[0,T]$</span> into <span>$m$</span> equi-spaced intervals. We use a finite difference scheme to solve the 1D heat equation Equations 1-3. Specifically, we use an implicit scheme for stability</p><div>\[\frac{u^{k+1}_i-u^k_i}{\Delta t} = \kappa_i \frac{u^{k+1}_{i+1}+u^{k+1}_{i-1}-2u^{k+1}_i}{\Delta x^2} + f_i^{k+1}, \quad k=1,2,\ldots, i=1,2,\ldots, n\]</div><p>where <span>$\Delta t$</span> is the time interval, <span>$\Delta x$</span> is the space interval, <span>$u_i^k$</span> is the numerical approximation to <span>$u((i-1)\Delta x, (k-1)\Delta t)$</span>, <span>$\kappa_i$</span> is the numerical approximation to <span>$\kappa((i-1)\Delta x)$</span>, and <span>$f_i^{k} = f((i-1)\Delta x, (k-1)\Delta t)$</span>.</p><p>For the insulated boundary, we introduce the ghost node <span>$u_{0}^k$</span>, which satisfies</p><div>\[-\kappa_1 \frac{u_2^{k}-u_0^k}{2\Delta x} = 0\tag{4}\]</div><p>(b) Let <span>$U^k = \begin{bmatrix}u_1^k\\u_2^k\\\vdots \\u_n^k\end{bmatrix}$</span> (note the index starts from 1 and ends with <span>$n$</span>), using the finite difference scheme, together with proper elimination of boundary values <span>$u_0^k$</span>, <span>$u_{n+1}^k$</span>, we have the following  formula</p><div>\[AU^{k+1} = U^k + F^k\]</div><p>Express the matrix <span>$A\in \mathbb{R}^{n\times n}$</span> in terms of <span>$\Delta t$</span>, <span>$\Delta x$</span> and <span>$\{\kappa_i\}_{i=1}^{n}$</span>; namely, what is <span>$A_{ij}$</span>? In addition, what is <span>$F^k\in \mathbb{R}^n$</span>?</p><p>(c) Now precompute in Julia the force vector <span>$F^k$</span> and pack it into a matrix <span>$F\in \mathbb{R}^{(m+1)\times n}$</span>. Using <a href="[https:/kailaix.github.io/ADCME.jl/dev/api/#ADCME.spdiag-Tuple{Integer,Vararg{Pair,N}%20where%20N}](https://kailaix.github.io/ADCME.jl/dev/api/#ADCME.spdiag-Tuple{Integer,Vararg{Pair,N} where N})">spdiag</a> to construct <code>A</code> as a <code>SparseTensor</code>. Use <span>$m=20$</span> and <span>$n=10$</span>. Use <span>$f(x, t) = \exp(-10(x-0.5)^2)$</span> for all the following questions of Problem 1. <span>$\kappa_i$</span> is given as a vector </p><pre><code class="language-julia">κ = constant(1 .+ exp.(Array(LinRange(0,1,n))))</code></pre><p>(d) The computational graph of the dynamical system can be efficiently constructed using <code>while_loop</code>. Conduct the forward computation using <code>while_loop</code>. For debugging, you can plot the temperature at the left side. You should have something similar to XXX. </p><p>Hint: You might want to read the documentation for <a href="[https:/kailaix.github.io/ADCME.jl/dev/api/#ADCME.while_loop-Tuple{Union{Function,%20PyObject},Function,Union{PyObject,%20Array{Any,N}%20where%20N,%20Array{PyObject,N}%20where%20N}}](https://kailaix.github.io/ADCME.jl/dev/api/#ADCME.while_loop-Tuple{Union{Function, PyObject},Function,Union{PyObject, Array{Any,N} where N, Array{PyObject,N} where N}})">while_loop</a> for its usage.</p><p>(e) Now we are ready to perform inverse modeling. Now using the initial guess</p><pre><code class="language-julia">κ = Variable(ones(n))</code></pre><p>Perform the mathematical optimization using <code>BFGS!</code>. Plot the <span>$\kappa$</span> values after the optimization converges. </p><p>Hint: To debug for your inverse modeling code, refer to <a href="https://kailaix.github.io/ADCME.jl/dev/tu_recipe/">Inverse Modeling Recipe</a></p><h2 id="Problem-2:-2D-Case-1"><a class="docs-heading-anchor" href="#Problem-2:-2D-Case-1">Problem 2: 2D Case</a><a class="docs-heading-anchor-permalink" href="#Problem-2:-2D-Case-1" title="Permalink"></a></h2><p>Now we consider the 2D case. We assume that <span>$\Omega=[0,1]^2$</span>, and <span>$\Gamma_u=\partial\Omega$</span>. In this case, we assume that the sensors are located at the following points</p><p>XXX</p><p>We still use the finite difference method to discretize the PDE. Additionally, a similar implicit scheme is used for stability</p><p>XXX</p><p>Let <span>$U^k$</span> be the vector of vectorized <span>$\{u_{ij}\}$</span>, and the order is <span>$u_{22}, u_{23}, \ldots, u_{2n}, u_{31}, \ldots, u_{nn}$</span>. Convince yourself that the evolution formula also has the form as Equation 4 (no need to provide justification). We provide a custom operator here XXX, which implements a differentiable SparseTensor <span>$A$</span> for you (refer to the instructions on how to compile and use it). </p><p>(a) Similar to Problem 1, conduct forward computation using <code>while_loop</code>. Plot  the curve of the temperature at <span>$(0.5,0.5)$</span>. For debugging, you should obtain something as follows</p><p>The parameters used in this problem: <span>$m=10$</span>, <span>$n=10$</span>, <span>$T=1$</span>, <span>$K=50$</span>, <span>$f(\mathbf{x},t) = e^{-t}\exp(-10\|\mathbf{x}-[0.5;0.5]\|^2_2)$</span>, <span>$\kappa(\mathbf{x}) = 1 + \|\mathbf{x}\|^2_2$</span></p><p>(b) Now assume <span>$\kappa(\mathbf{x})$</span> is unknown but we have observations from the sensors (the observations can be computed using the forward simulation code you just developed). Conduct mathematical optimization using <code>BFGS!</code>. The initial guess for <span>$\kappa$</span> is <span>$\kappa(\mathbf{x})=1$</span>. </p><p>(c) (Bonus) Can you implement a custom operator kernel for the 1D case? </p><p>Warning: This problem may be time consuming, but this technique is frequently used for developing high performance codes for inverse modeling. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tu_implicit/">« Advanced: Automatic Differentiation for Implicit Operators</a><a class="docs-footer-nextpage" href="../newton_raphson/">Newton Raphson »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 28 March 2020 19:47">Saturday 28 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
