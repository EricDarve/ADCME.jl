<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview · ADCME</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href><img class="logo" src="assets/logo.png" alt="ADCME logo"/></a><h1>ADCME</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Overview</a><ul class="internal"><li><a class="toctext" href="#Getting-Started-1">Getting Started</a></li></ul></li><li><a class="toctext" href="inverse_modeling/">Inverse Modeling</a></li><li><span class="toctext">Resources</span><ul><li><a class="toctext" href="customop/">Custom Operators</a></li><li><a class="toctext" href="while_loop/">While Loops</a></li><li><a class="toctext" href="newton_raphson/">Newton Raphson</a></li><li><a class="toctext" href="julia_customop/">Julia Custom Operators</a></li><li><a class="toctext" href="pytorchnn/">Neural Network in C++</a></li><li><a class="toctext" href="extra/">Miscellaneous Tools</a></li><li><a class="toctext" href="array/">Array Operations</a></li></ul></li><li><span class="toctext">Applications</span><ul><li><a class="toctext" href="apps_ana/">Adversarial Numerical Analysis</a></li><li><a class="toctext" href="apps_levy/">Calibrating Multivariate Lévy Processes with Neural Networks</a></li><li><a class="toctext" href="apps_constitutive_law/">Learning Constitutive Relations from Indirect Observations Using Deep Neural Networks</a></li></ul></li><li><a class="toctext" href="api/">API Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Overview</a></li></ul><a class="edit-page" href="https://github.com/kailaix/ADCME.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Overview</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h1><p>ADCME is suitable for conducting inverse modeling in scientific computing. The purpose of the package is to: (1) provide differentiable programming framework for scientific computing based on TensorFlow automatic differentiation (AD) backend; (2) adapt syntax to facilitate implementing scientific computing, particularly for numerical PDE discretization schemes; (3) supply missing functionalities in the backend (TensorFlow) that are important for engineering, such as sparse linear algebra, constrained optimization, etc. Applications include</p><ul><li><p>full wavelength inversion</p></li><li><p>reduced order modeling in solid mechanics</p></li><li><p>learning hidden geophysical dynamics</p></li><li><p>physics based machine learning</p></li><li><p>parameter estimation in stochastic processes</p></li></ul><p>The package inherents the scalability and efficiency from the well-optimized backend TensorFlow. Meanwhile, it provides access to incooperate existing C/C++ codes via the custom operators. For example, some functionalities for sparse matrices are implemented in this way and serve as extendable &quot;plugins&quot; for ADCME. </p><h2><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h2><p>To install ADCME, simply type the following commands in Julia REPL</p><pre><code class="language-none">julia&gt; using Pkg; Pkg.add(&quot;ADCME&quot;)</code></pre><p>To enable GPU support for custom operators (if you do not need to compile custom operators, you do not need this step), make sure <code>nvcc</code> command is available on your machine, then</p><pre><code class="language-julia">using ADCME
enable_gpu()</code></pre><p>We consider a simple inverse modeling problem: consider the following partial differential equation</p><div>\[-bu&#39;&#39;(x)+u(x)=f(x)\quad x\in[0,1], u(0)=u(1)=0\]</div><p>where </p><div>\[f(x) = 8 + 4x - 4x^2\]</div><p>Assume that we have observed <span>$u(0.5)=1$</span>, we want to estimate <span>$b$</span>. The true value in this case should be <span>$b=1$</span>. We can discretize the system using finite difference method, and the resultant linear system will be</p><div>\[(bA+I)\mathbf{u} = \mathbf{f}\]</div><p>where</p><div>\[A = \begin{bmatrix}
        \frac{2}{h^2} &amp; -\frac{1}{h^2} &amp; \dots &amp; 0\\
         -\frac{1}{h^2} &amp; \frac{2}{h^2} &amp; \dots &amp; 0\\
         \dots \\
         0 &amp; 0 &amp; \dots &amp; \frac{2}{h^2}
    \end{bmatrix}, \quad \mathbf{u} = \begin{bmatrix}
        u_2\\
        u_3\\
        \vdots\\
        u_{n}
    \end{bmatrix}, \quad \mathbf{f} = \begin{bmatrix}
        f(x_2)\\
        f(x_3)\\
        \vdots\\
        f(x_{n})
    \end{bmatrix}\]</div><p>The idea for implementing the inverse modeling method in ADCME is that we make the unknown <span>$b$</span> a <code>Variable</code> and then solve the forward problem pretending <span>$b$</span> is known. The following code snippet shows the implementation</p><pre><code class="language-julia">using LinearAlgebra
using ADCME

n = 101 # number of grid nodes in [0,1]
h = 1/(n-1)
x = LinRange(0,1,n)[2:end-1]

b = Variable(10.0) # we use Variable keyword to mark the unknowns
A = diagm(0=&gt;2/h^2*ones(n-2), -1=&gt;-1/h^2*ones(n-3), 1=&gt;-1/h^2*ones(n-3)) 
B = b*A + I  # I stands for the identity matrix
f = @. 4*(2 + x - x^2) 
u = B\f # solve the equation using built-in linear solver
ue = u[div(n+1,2)] # extract values at x=0.5

loss = (ue-1.0)^2 

# Optimization
sess = Session(); init(sess) 
BFGS!(sess, loss)

println(&quot;Estimated b = &quot;, run(sess, b))</code></pre><p>The expected output is</p><pre><code class="language-none">Estimated b = 0.9995582304494237</code></pre><footer><hr/><a class="next" href="inverse_modeling/"><span class="direction">Next</span><span class="title">Inverse Modeling</span></a></footer></article></body></html>
